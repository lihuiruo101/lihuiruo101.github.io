<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Monitor-style Curve Comet Background</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;600;800&display=swap');

  :root{
    --bg:#0b0b10;
    --panel:#0f0f13;
    --accent1: #8b5cf6;
    --accent2: #06b6d4;
    --accent3: #3b82f6;
    --accent4: #fb7185;
  }

  html,body{
    height:100%;
    margin:0;
    background: var(--bg);
    font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans KR', sans-serif;
    color:#ddd;
  }

  /* 전체 레이아웃: 좌측(명언) + 우측(로그인) 같은 모니터 느낌 */
  .wrap {
    display:flex;
    height:100vh;
    align-items:stretch;
  }

  .left {
    flex:1;
    position:relative;
    overflow:hidden;
    background: linear-gradient(140deg, rgba(6,6,10,0.6), rgba(10,10,18,0.85));
  }

  /* 캔버스가 왼쪽 전체를 차지 */
  #bgCanvas{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    display:block;
  }

  .quoteBox{
    position:absolute;
    bottom:28px;
    left:28px;
    z-index:3;
    max-width:48%;
    color:#cbd5e1;
    font-weight:500;
    text-shadow: 0 6px 18px rgba(0,0,0,0.6);
    pointer-events:none;
  }
  .quote{
    font-size:18px;
    line-height:1.3;
    opacity:0;
    transform:translateY(8px);
    transition: all .7s cubic-bezier(.2,.9,.2,1);
  }
  .quote.show{
    opacity:1;
    transform:translateY(0);
  }
  .quote small{
    display:block;
    margin-top:8px;
    color:#94a3b8;
    font-size:13px;
    font-weight:400;
  }

  /* 오른쪽 로그인 박스 (데모용) */
  .right {
    width:420px;
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-left:1px solid rgba(255,255,255,0.03);
    padding:40px;
  }
  .login {
    width:100%;
    max-width:320px;
    background: rgba(10,10,12,0.6);
    padding:28px;
    border-radius:12px;
    box-shadow: 0 10px 40px rgba(8,8,12,0.6);
    backdrop-filter: blur(6px);
    color:#e6eef8;
  }
  .login h2{
    margin:0 0 12px 0;
    font-size:22px;
    letter-spacing:0.4px;
  }
  .login input{
    width:100%;
    padding:10px 12px;
    margin-top:10px;
    background: rgba(255,255,255,0.03);
    border:1px solid rgba(255,255,255,0.04);
    color:inherit;
    border-radius:8px;
    outline:none;
  }
  .login button{
    margin-top:14px;
    width:100%;
    padding:10px;
    border-radius:8px;
    border:none;
    font-weight:700;
    cursor:pointer;
    background: linear-gradient(90deg,var(--accent2),var(--accent3));
    color:#04111f;
  }

  /* 모바일: 캔버스 숨김 (폰에서는 궤적 안보이게) */
  @media (max-width: 768px){
    #bgCanvas, .quoteBox{ display:none; }
    .wrap{ flex-direction:column; }
    .right{ width:100%; height:100vh; border-left:none; padding:30px; }
  }

  /* 작은 장식: 모니터 프레임 느낌(선택사항) */
  .frameTop{
    position:absolute;
    top:8px;
    left:8px;
    right:8px;
    height:36px;
    z-index:6;
    display:flex;
    align-items:center;
    justify-content:flex-start;
    gap:8px;
    pointer-events:none;
  }
  .dot{ width:12px; height:12px; border-radius:50%; background:rgba(255,255,255,0.06); box-shadow:0 1px 0 rgba(255,255,255,0.02) }
</style>
</head>
<body>
  <div class="wrap">
    <div class="left">
      <canvas id="bgCanvas"></canvas>

      <div class="frameTop" aria-hidden>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>

      <div class="quoteBox" id="quoteBox" aria-live="polite">
        <!-- quotes populated by JS -->
      </div>
    </div>

    <div class="right">
      <div class="login">
        <h2>로그인 👋</h2>
        <input placeholder="아이디를 입력하세요" />
        <input placeholder="비밀번호를 입력하세요" type="password" />
        <button>로그인하기</button>
        <div style="margin-top:10px; font-size:13px; color:#9fb0c9;">아직 계정이 없으신가요? <a href="#" style="color:#9fe3ff">회원가입</a></div>
      </div>
    </div>
  </div>

<script>
/* ====== 설정 ====== */
const PALETTE = [
  '#8b5cf6', // 보라
  '#06b6d4', // 청록
  '#3b82f6', // 파랑
  '#fb7185'  // 핑크
];

const QUOTES = [
  {text: "There are no traffic jams along the extra mile.", by: "Roger Staubach"},
  {text: "Simplicity is the keynote of all true elegance.", by: "Coco Chanel"},
  {text: "Do the thing you fear and the death of fear is certain.", by: "Ralph Waldo Emerson"},
  {text: "Small deeds done are better than great deeds planned.", by: "Peter Marshall"},
  {text: "Stay hungry, stay foolish.", by: "Steve Jobs"}
];

const canvas = document.getElementById('bgCanvas');
const ctx = canvas.getContext('2d', { alpha: true });

let DPR = Math.max(1, window.devicePixelRatio || 1);
function resizeCanvas(){
  DPR = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(canvas.clientWidth * DPR);
  canvas.height = Math.floor(canvas.clientHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resizeCanvas);

/* ====== Comet 클래스 ====== */
class Comet {
  constructor(bounds){
    this.w = bounds.width; this.h = bounds.height;
    this.reset(true);
  }

  // 베지어 곡선 컨트롤 포인트 생성 (화면 밖에서 들어와 밖으로 나가도록)
  reset(initial=false){
    const margin = 40;
    // 시작과 끝은 화면 가장자리 근처 랜덤 위치
    const side = Math.random();
    // choose two random edges for start / end
    this.p0 = this.randomEdgePoint();
    this.p3 = this.randomEdgePoint();
    // ensure they are not too close
    while (dist(this.p0, this.p3) < Math.min(this.w,this.h)*0.3) this.p3 = this.randomEdgePoint();

    // two control points inside screen to make a smooth curve
    this.p1 = { x: lerp(this.p0.x, this.p3.x, 0.25) + randRange(-this.w*0.25,this.w*0.25),
                y: lerp(this.p0.y, this.p3.y, 0.25) + randRange(-this.h*0.25,this.h*0.25) };
    this.p2 = { x: lerp(this.p0.x, this.p3.x, 0.75) + randRange(-this.w*0.25,this.w*0.25),
                y: lerp(this.p0.y, this.p3.y, 0.75) + randRange(-this.h*0.25,this.h*0.25) };

    this.t = initial ? Math.random() * 0.8 : 0; // animation parameter (0..1)
    this.speed = randRange(0.003, 0.008) * (0.6 + Math.random()); // base speed
    this.color = PALETTE[Math.floor(Math.random()*PALETTE.length)];
    this.width = randRange(1.2, 2.8);
    this.tailLen = Math.floor(randRange(10, 38));
    this.positions = []; // tail history
    this.done = false;
    // slight speed variation over time
    this.speedVariation = randRange(0.0002, 0.0008);
  }

  randomEdgePoint(){
    const side = Math.floor(Math.random()*4);
    switch(side){
      case 0: return {x: randRange(-80, this.w+80), y: -randRange(20,80)}; // top
      case 1: return {x: this.w + randRange(20,80), y: randRange(-80,this.h+80)}; // right
      case 2: return {x: randRange(-80,this.w+80), y: this.h + randRange(20,80)}; // bottom
      default: return {x: -randRange(20,80), y: randRange(-80,this.h+80)}; // left
    }
  }

  update(dt){
    // small speed wobble
    this.t += this.speed + Math.sin(this.t * 3.14 * 2) * this.speedVariation;
    if(this.t > 1.02){
      this.done = true;
      return;
    }
    // position on cubic bezier
    const pos = cubicPoint(this.p0,this.p1,this.p2,this.p3, this.t);
    // push to positions (tail)
    this.positions.unshift(pos);
    if(this.positions.length > this.tailLen) this.positions.pop();
  }

  draw(ctx){
    if(this.positions.length < 1) return;
    // draw tail with gradient along positions
    ctx.save();
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    // draw multiple segments with decreasing alpha and width
    for(let i=0;i<this.positions.length-1;i++){
      const a = 1 - (i/this.positions.length); // alpha taper
      const pA = this.positions[i];
      const pB = this.positions[i+1];
      ctx.beginPath();
      ctx.moveTo(pA.x, pA.y);
      ctx.lineTo(pB.x, pB.y);
      ctx.strokeStyle = colorWithAlpha(this.color, 0.18 * a);
      ctx.lineWidth = this.width * (1.2 * a);
      ctx.stroke();
    }
    // draw head (glowing)
    const head = this.positions[0];
    if(head){
      const g = ctx.createRadialGradient(head.x, head.y, 0, head.x, head.y, Math.max(8, this.width*6));
      g.addColorStop(0, colorWithAlpha(this.color, 0.98));
      g.addColorStop(0.4, colorWithAlpha(this.color, 0.35));
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(head.x, head.y, 6 + this.width*2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }
}

/* ====== 유틸 함수 ====== */
function randRange(a,b){ return a + Math.random()*(b-a); }
function lerp(a,b,t){ return a + (b-a)*t; }
function cubicPoint(p0,p1,p2,p3,t){
  // cubic bézier
  const u = 1 - t;
  const tt = t*t, uu = u*u, ttt = tt*t, uuu = uu*u;
  const x = uuu*p0.x + 3*uu*t*p1.x + 3*u*tt*p2.x + ttt*p3.x;
  const y = uuu*p0.y + 3*uu*t*p1.y + 3*u*tt*p2.y + ttt*p3.y;
  return {x,y};
}
function colorWithAlpha(hex, a){
  // hex like #rrggbb
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return `rgba(${r},${g},${b},${a})`;
}
function dist(a,b){
  const dx = a.x-b.x, dy = a.y-b.y;
  return Math.sqrt(dx*dx+dy*dy);
}

/* ====== 시뮬 초기화 및 루프 ====== */
let comets = [];
let last = 0;
let spawnTimer = 0;

function init(){
  resizeCanvas();
  comets = [];
  // initial comets
  for(let i=0;i<6;i++){
    comets.push(new Comet({width: canvas.clientWidth, height: canvas.clientHeight}));
  }
  window.requestAnimationFrame(loop);
}
function loop(ts){
  if(!last) last = ts;
  const dt = (ts - last) / 1000;
  last = ts;

  // clear with a little alpha so trails persist softly
  ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);

  // background subtle vignette or noise (optional)
  // draw overlay grid of faint arcs (not required)

  // update and draw comets
  for(let i=comets.length-1;i>=0;i--){
    const c = comets[i];
    c.update(dt);
    c.draw(ctx);
    if(c.done){
      comets.splice(i,1);
    }
  }

  // spawn new comets occasionally, with randomness
  spawnTimer -= dt;
  if(spawnTimer <= 0){
    // spawn 1-2 comets at a time sometimes
    const toSpawn = Math.random() < 0.6 ? 1 : Math.floor(randRange(1,3));
    for(let s=0;s<toSpawn;s++){
      comets.push(new Comet({width: canvas.clientWidth, height: canvas.clientHeight}));
      // cap number of comets for performance
      if(comets.length > 28) break;
    }
    spawnTimer = randRange(0.8, 2.5); // variable spawn interval
  }

  // subtle overlay: faint colored arcs to enhance depth
  drawOverlay();

  window.requestAnimationFrame(loop);
}

/* overlay effect for depth */
function drawOverlay(){
  // a few soft sweeping arcs
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  const centerX = canvas.clientWidth * 0.5;
  const centerY = canvas.clientHeight * 0.5;

  for(let i=0;i<3;i++){
    const radius = Math.min(canvas.clientWidth, canvas.clientHeight) * (0.5 + i*0.12);
    const grad = ctx.createRadialGradient(centerX, centerY, radius*0.2, centerX, centerY, radius);
    const color = PALETTE[i % PALETTE.length];
    grad.addColorStop(0, colorWithAlpha(color, 0.01));
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();
}

/* ====== quote rotation ====== */
const quoteBox = document.getElementById('quoteBox');
function showQuotes(){
  quoteBox.innerHTML = ''; // clear
  QUOTES.forEach((q, idx) => {
    const el = document.createElement('div');
    el.className = 'quote';
    el.innerHTML = `<div>“${q.text}”</div><small>— ${q.by}</small>`;
    quoteBox.appendChild(el);
  });

  let active = 0;
  const items = quoteBox.querySelectorAll('.quote');
  function setActive(n){
    items.forEach((it, i) => {
      it.classList.toggle('show', i === n);
    });
  }
  setActive(active);
  setInterval(()=> {
    active = (active + 1) % items.length;
    setActive(active);
  }, 6000);
}

/* ====== 시작 ====== */
function startIfVisible(){
  // only run heavy canvas on wide screens (desktop)
  if(window.innerWidth <= 768){
    // mobile - do nothing heavy
    canvas.style.display = 'none';
  } else {
    canvas.style.display = 'block';
    resizeCanvas();
    init();
  }
}

window.addEventListener('load', ()=>{
  showQuotes();
  startIfVisible();
});
window.addEventListener('resize', ()=>{
  // re-init when crossing threshold
  if(window.innerWidth <= 768){
    canvas.style.display = 'none';
  } else {
    canvas.style.display = 'block';
    resizeCanvas();
  }
});
</script>
</body>
        </html>
